/** 
 * SARL-MASSIM - Interface between the SARL agent-oriented language 
 * and the MASSIM 2017 server
 * Copyright (C) 2017 The SARL-MASSIM Authors.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package au.edu.rmit.agtgrp.agtcity.sarl.agents.dummy

// MASSIM EIS imports
import eis.iilang.Action // needed to do actions
import eis.iilang.Percept // needed to process percepts
import eis.iilang.EnvironmentState;

// SARL imports
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules

// General Java tools
import java.nio.file.Paths
import java.util.Collection
import java.util.Random
import java.util.Set

import eis.exceptions.PerceiveException
import eis.exceptions.ActException
import eis.iilang.Identifier
import eis.iilang.PrologVisitor
import eis.iilang.IILVisitor

// Import project content
import au.edu.rmit.agtgrp.agtcity.sarl.events.E_ReportInfo
import au.edu.rmit.agtgrp.agtcity.sarl.events.E_MoveRandomly
import au.edu.rmit.agtgrp.agtcity.sarl.events.E_SenseEnvironment
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_Reporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_MassimTalking
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_ConsoleReporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_MassimTalking17

import au.edu.rmit.agtgrp.agtcity.sarl.mw.utils.ConfHandler
import au.edu.rmit.agtgrp.agtcity.sarl.mw.entities.PlayerState

import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.Util
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.PerceptAggregator
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.PlayerStateBuilder

/** 
 * @author Sebastian Sardina (ssardina@gmail.com
 * 
 * This is a monolithic SARL agent that uses the S_MassimTalking17 skill 
 * to manage ALL the players in the  game simulation.
 */
agent SuperSingleAgent {
	uses Logging, Lifecycle, DefaultContextInteractions, Schedules
	uses C_Reporting, C_MassimTalking

	val DEFAULT_LOG_LEVEL = 3 // debug = 4 ; info = 3 ; warning = 2 ; error = 1

	// Data kept by this single SARL agent: just the step number
	var last_step : int	
	var rand : Random

	// This is an important structure that contains the aggregated sensing of all agents
	// This together with the PlayerState (via MT_getPlayerState(playerName)) of each agent provide the snapshot of the game
	var sensingAggregator : PerceptAggregator // used to collect all the (common) percepts from all agents (provided by MW)



	/* 
	 * Agent may receive the path directory where the config files for server connection
	 * and player authentications are located. Otherwise, will query via terminal.
	 */
	on Initialize { // Should only be initializing with the EIS as a parameter.
		{
			var args = newArrayList(occurrence.parameters) // may receive directory conf directory
			var eiConfigDir : String = ""
			val eiMassimConfigFile = "eismassimconfig.json"
			val eiMassimPlayerAgentsConfigFile = "agentsconfig.json"
			rand = new Random()
			sensingAggregator = new PerceptAggregator() // collect all the percepts from all agents

			/* 
			 * 1 - Give reporting skill via console & set log level
			 */
			setSkill(new S_ConsoleReporting("Super-Single-Agent"), C_Reporting)
			val log_level : int = Integer.parseInt(System.getProperty("loglevel", String.valueOf(DEFAULT_LOG_LEVEL)))
			info("============+> SETTING LOG LEVEL TO: {0}", log_level)
			setLogLevel(log_level)

			info("This is an INFO TEST message (level 3)....")
			warning("This is a WARNING TEST message (level 2)....")
			error("This is an ERROR TEST message (level 1)....")

			/* 
			 * 2 - Next, we equip the SARL agent with the MassinTalking capability to control some agents.
			 * We provide two pieces of information:
			 * The server configuration is in file eiMassimConfigFile
			 * The agents to control are specified in file eiMassimPlayerAgentsConfigFile
			 * 
			 * Note this does not connect or start the EI, it just stores the information in the skill
			 */
			agent_says("PHASE 1: REGISTERING MASSIM TALKING SKILL VIA CONFIGURATION FILES {0} AND {1}",
				eiMassimConfigFile, eiMassimPlayerAgentsConfigFile)
			if (args.length != 0)
				eiConfigDir = args.get(0) as String
			else {
				eiConfigDir = ConfHandler.getConfDir()
			}
			// Give agent ability to talk to MASSIM server
			setSkill(new S_MassimTalking17(Paths.get(eiConfigDir, eiMassimConfigFile),
					Paths.get(eiConfigDir, eiMassimPlayerAgentsConfigFile)), C_MassimTalking)

			/* 
			 * 3 - Time to really create and initialize the EI. 
			 * No player connections are yet register. 
			 * This only uses the server configuration file (e.g., host and ip of serer): eiMassimConfigFile
			 */
			agent_says("PHASE 2: INITIALIZING ENVIRONMENT INTERFACE USING CONFIGURATION FILE {0} ", eiMassimConfigFile)
			if (MT_initialize()) {
				agent_says("The EI is now initialized, entities are being authenticated...")
			} else {
				agent_says("Something wrong when registering the game server, I am finished...")
				killMe
			}

			/* 
			 * 6 - Once the EIS is started, we finally register the players we will control
			 * This uses the player agent configuration file: eiMassimPlayerAgentsConfigFile
			 */
			agent_says("PHASE 3: REGISTERING AGENTS INTO ENVIRONMENT (GAME ENGINE) VIA FILE {0}",
				eiMassimPlayerAgentsConfigFile)
			MT_registerPlayersFromConfig()

			agent_shouts("I am now alive! Will start working now (sending and acting!)...")
			// We are ready, now start the cycle for sensing the environment (and thus acting)!
			// Wait for 2 secs to make sure everybody is connected and authenticated
			in(2000)[emit(new E_SenseEnvironment())]
		}
	}

	/* 
	 * Handle the process of sensing the environment
	 */
	on E_SenseEnvironment {
		agent_shouts("Start sensing the environment")
		var step = 0

		// Initializes three static data buffers for ENTITIES (agents), TEAM, and SIM-START
		// Util is provided by the MW as part of the aggregator package
		// TODO: why I cannot just do Util.initDataBuffers()? It complains that it has no side-effect
		if (Util.initDataBuffers()) {}

		// While the environment is running, wait for new percepts (read percepts for each player registered/connnected)
		while (MT_getStatus() == EnvironmentState.RUNNING) {
			MT_getPlayersNames().forEach([ playerName : String |
	
				// all percepts for the player: (role/entity of agent --> collection of single percepts)
					// In this game, players usually are of one role/entity, so we will store that single set of percepts
					// in variable percepts (the first value of allPercepts)
				var percepts : Collection<Percept>
				try {
					percepts = MT_sensePlayerPercepts(playerName) // This is blocking!
					

					// Process the percepts by updating the PlayerState of the player in question
					// The skill S_MassimTalking17 maintains a PlayerState object per player
					// But this is already done automatically when the player senses! So not needed to do it again
					// MT_getPlayerState(playerName).update(percepts) // update the agent data

					// Populate general data (entity, team, simstart) static buffers
					if (Util.populateDataBuffers(percepts)) {
					}

					// SELF:
					//	Add the action results of playerName(self) to percept aggregator
					//	Add an the agent state for the playerNamein the aggregator (contains location, items holding, etc)
					sensingAggregator.addActionResults(playerName, percepts)
					var PlayerState = PlayerStateBuilder.build(playerName, percepts) // build a new agent state from percept
					sensingAggregator.addTeamMember(playerName, PlayerState) // Fill the aggregator with this agent state for playerName


					// FACILITIES: Aggregate all facilities information that are the same info for everyone
					// (shop, workshops, charging stations, dump, storage, resourceNodes)
					sensingAggregator.addFacilities(percepts)


					// OTHER ENTITIES:
                    //	Add to aggregator the info of all other entities that are not part of the team (not agents)
					sensingAggregator.addEntities()

					// JOBS: Aggregate all jobs (job, auction, mission, or posted)
					sensingAggregator.addJobs(percepts)
	
					// update the last step if the percept just processed has a higher step number
					if(last_step < MT_getPlayerState(playerName).step) last_step = MT_getPlayerState(playerName).step
	
					agent_shouts("I am finished sensing the environment - Step {0} for player {1}",
						MT_getPlayerState(playerName).step, playerName)
				} catch (e : PerceiveException) {
					agent_shouts("There was an exception perceiving for player {0}: {1}", playerName, e.message)
				} catch (e : Exception) {
					error("Something bad has happened during perception for player {0}: {1}", playerName, e.toString)
				}
			])

			agent_shouts("Finished sensing the environment for all players. Will instruct action for step {0}!",
				last_step)
	
			// 1 - Report some information per agent
			emit(new E_ReportInfo())
	
			// 2 - Travel to some random facility
			MT_getPlayersNames.forEach([ playerName2 : String |
				emit(new E_MoveRandomly => [playerName = playerName2]) // see compact way of assignment data in event
				])
		} // END OF WHILE
		agent_shouts("Environment Interface not running anymore, done sensing....")
	}	// END OF BEHAVIOR



	/**
	 * NAVIGATE TO RAMDOM FACILITY
	 * 
	 * Just report whatever you want the user to know.. (presumably, done after perception cycle)
	 */
	on E_ReportInfo {
		MT_getPlayersNames().forEach([ playerName : String |
			agent_says(MT_getPlayerState(playerName).reportState()) 		// report agent state
		])		
	}


	/**
	 * NAVIGATE TO RAMDOM FACILITY
	 * 
	 * These two behaviors make the player move towards any random facility
	 */
	on E_MoveRandomly [(MT_getPlayerState(occurrence.playerName).routeLength > 0)] {
		// we are still traveling, just continue following the path...
		val playerName = occurrence.playerName

		agent_says("Seems player {0} is already travelling: {1} steps to go!", playerName,
			MT_getPlayerState(playerName).routeLength)

		performAction(playerName, new Action("continue"))
	}

	on E_MoveRandomly [!(MT_getPlayerState(occurrence.playerName).routeLength > 0)] {
		// We are not following any route, just go somewhere!	
		val playerName = occurrence.playerName
		val facilities = sensingAggregator.getFacilitiesNames()
		
		if (facilities == null || sensingAggregator.getFacilitiesNames().length == 0 ) {
			agent_shouts("I just don't know any facility to go, sorry...!")
		} else {
			// Pick some random facility and go!
			val destination = facilities.get(rand.nextInt(facilities.length - 1))
			performAction(playerName, new Action("goto", new Identifier(destination)))
			agent_says("I will send player {1} to navigating towards destination {0}", destination, playerName)
		}
	}


	/** 
	 * A basic method for sending actions the the EIS server
	 * If sending fails, the exception is caught and logged. 
	 */
	def performAction(playerName : String, action : Action) {
		agent_says("Performing action {1} for player {0}", playerName, action.toProlog())
		try {
			// perform the action by agentName in the EIS
			MT_executeAction(playerName, action)
		} catch (e : ActException) {
			if (action !== null)
				warning("Could not perform action {0} for player {1}", action, playerName)
		}
	}

}
// /////////////////////////////////////////////////
// END OF FILE
// ///////////////////////////////////////////////// 