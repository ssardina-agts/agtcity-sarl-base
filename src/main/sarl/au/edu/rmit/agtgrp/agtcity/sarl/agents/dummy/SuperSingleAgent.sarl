/** 
 * SARL-MASSIM - Interface between the SARL agent-oriented language 
 * and the MASSIM 2017 server
 * Copyright (C) 2017 The SARL-MASSIM Authors.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package au.edu.rmit.agtgrp.agtcity.sarl.agents.dummy

// MASSIM EIS imports
import eis.iilang.Action // needed to do actions
import eis.iilang.Percept // needed to process percepts
import eis.iilang.EnvironmentState;

// SARL imports
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging

// General Java tools
import java.util.*;
import java.nio.file.Paths

import eis.exceptions.PerceiveException
import eis.exceptions.ActException
import eis.iilang.Identifier

// Import project content
import au.edu.rmit.agtgrp.agtcity.sarl.mw.utils.ConfHandler
import au.edu.rmit.agtgrp.agtcity.sarl.mw.entities.PlayerState

import au.edu.rmit.agtgrp.agtcity.sarl.mw.events.*
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_Reporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.capacities.C_MassimTalking
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_ConsoleReporting
import au.edu.rmit.agtgrp.agtcity.sarl.mw.skills.S_MassimTalking17
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.SimStartBuffer
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.Util
import au.edu.rmit.agtgrp.agtcity.sarl.mw.aggregator.PerceptAggregator

import eis.iilang.PrologVisitor
import eis.iilang.IILVisitor
import au.edu.rmit.agtgrp.agtcity.sarl.events.E_ReportInfo
import au.edu.rmit.agtgrp.agtcity.sarl.events.E_MoveRandomly

/** 
 * @author Sebastian Sardina (ssardina@gmail.com
 * 
 * This is a monolithic SARL agent that uses the S_MassimTalking17 skill 
 * to manage ALL the players in the  game simulation.
 */
agent SuperSingleAgent {
	uses Logging, Lifecycle, DefaultContextInteractions
	uses C_Reporting, C_MassimTalking

	val agentLogLevel = 3 // debug = 4

	// Data kept by this single SARL agent: just the step number
	var last_step : int
	var facilities : Set<String>
	var rand : Random
	var aggregator : PerceptAggregator // used to collect all the (common) percepts from all agents (provided by MW)

	/* 
	 * Agent may receive the path directory where the config files for server connection
	 * and player authentications are located. Otherwise, will query via terminal.
	 */
	on Initialize { // Should only be initializing with the EIS as a parameter.
		{
			var args = newArrayList(occurrence.parameters) // may receive directory conf directory
			var eiConfigDir : String = ""
			val eiMassimConfigFile = "eismassimconfig.json"
			val eiMassimAuthConfigFile = "agentsconfig.json"

			rand = new Random()


		aggregator = new PerceptAggregator() // collect all the percepts from all agents
			// Give reporting skill via console
			setSkill(new S_ConsoleReporting("Super-Single-Agent"), C_Reporting)
			setLogLevel(4)

			agent_says("PHASE 1: REGISTERING MASSIM TALKING SKILL VIA CONFIGURATION FILES {0} AND {1}",
				eiMassimConfigFile, eiMassimAuthConfigFile)
			if (args.length != 0)
				eiConfigDir = args.get(0) as String
			else {
				eiConfigDir = ConfHandler.getConfDir()
			}
			// Give agent ability to talk to MASSIM server
			setSkill(new S_MassimTalking17(Paths.get(eiConfigDir, eiMassimConfigFile),
					Paths.get(eiConfigDir, eiMassimAuthConfigFile)), C_MassimTalking)

			agent_says("PHASE 2: INITIALIZING ENVIRONMENT INTERFACE USING CONFIGURATION FILE {0} ", eiMassimConfigFile)
			if (MT_initialize()) {
        	agent_says("I have initialized the EI successfully!")
			} else {
			agent_says("Something wrong when registering the game server, I am finished...")
				killMe
			}

			agent_says("PHASE 3: REGISTERING AGENTS INTO ENVIRONMENT (GAME ENGINE) VIA FILE {0}",
				eiMassimAuthConfigFile)
			MT_registerPlayersFromConfig()

			agent_shouts("I am now alive! Will start working now (sending and acting!)...")

			// We are ready, now start the cycle for sensing the environment (and thus acting)!
			emit(new E_SenseEnvironment())
		}
	}

	/* 
	 * Handle the process of sensing the environment
	 */
	on E_SenseEnvironment {
		agent_shouts("Start sensing the environment")
		var step = 0

		// Initializes three static data buffers for entities, teams and sim-start
		// Util is provided by the MW as part of the aggregator package
		if (Util.initDataBuffers()) {
		} else {
			warning("For some reason I was not able to initialize the data buffers")
		}

		// While the environment is running, wait for new percepts (read percepts for each player registered/connnected)
		while (MT_getStatus() == EnvironmentState.RUNNING) {
			MT_getPlayersNames().forEach([ playerName : String |

				// all percepts for the player: (role/entity of agent --> collection of single percepts)
				// In this game, players usually are of one role/entity, so we will store that single set of percepts
				// in variable percepts (the first value of allPercepts)
				var allPercepts : Map<String, Collection<Percept>>
				var percepts : Collection<Percept>	
				try {
					allPercepts = MT_sensePlayerPercepts(playerName) // This is blocking!

					// Now get just the first set of percepts for the first entity type
					// as players are in the game of just one entity/role
					percepts = allPercepts.values().get(0)
				} catch (e : PerceiveException) {
					agent_shouts("I am sorry, there seems to be an error in perception. Killing myself..")
						error(e.toString)
					e.printStackTrace()
					killMe
				}

				// Process the percepts by updating the PlayerState of the player in question
				// The skill S_MassimTalking17 maintains a PlayerState object per player
				MT_getPlayerState(playerName).update(percepts) // update the agent data

				// FACILITIES: Aggregate all facilities information that are the same info for everyone
				// (shop, workshops, charging stations, dump, storage, resourceNodes)
				if (Util.populateDataBuffers(percepts)) {
				} else {
					warning("For some reason I was not able to populate the data buffers with the percepts")
				}
				aggregator.addFacilities(percepts)
				facilities = aggregator.getFacilitiesNames()

				// update the last step if the percept just processed has a higher step number
				if(last_step < MT_getPlayerState(playerName).step) last_step = MT_getPlayerState(playerName).step
				agent_shouts("I am finished sensing the environment - Step {0} for player {1}",
					MT_getPlayerState(playerName).step, playerName)
			])

			agent_shouts(
				"I am finished sensing the environment for all the players. I will instruct action for step {0}!",
				last_step)

			// All percepts per agent read. Report some information and do something per agent
			emit(new E_ReportInfo())

//			// All percepts per agent read, now do some actions in the world
//			emit(new E_Act())

			// 5. Very finally, do some some movement per agent
			MT_getPlayersNames.forEach([ playerName2 : String |
				emit(new E_MoveRandomly => [playerName = playerName2]) // see compact way of assignment data in event
			])

		}

		agent_shouts("Environment Interface not running anymore, done sensing....")
	}

	/**
	 * NAVIGATE TO RAMDOM FACILITY
	 * 
	 * Just report whatever you want the user to know.. (presumably, done after perception cycle)
	 */
	on E_ReportInfo {
		MT_getPlayersNames().forEach([ playerName : String |
			agent_says(MT_getPlayerState(playerName).reportState()) 		// report agent state
		])		
	}


	/**
	 * NAVIGATE TO RAMDOM FACILITY
	 * 
	 * These two behaviors make the player move towards any random facility
	 */
	on E_MoveRandomly [(MT_getPlayerState(occurrence.playerName).routeLength > 0)] {
		// we are still traveling, just continue following the path...
		val playerName = occurrence.playerName

		agent_says("Seems player {0} is already am moving: {1} steps to go!", playerName,
			MT_getPlayerState(playerName).routeLength)

		performAction(playerName, new Action("continue"))
	}

	on E_MoveRandomly [!(MT_getPlayerState(occurrence.playerName).routeLength > 0)] {
		// We are not following any route, just go somewhere!	
		val playerName = occurrence.playerName

		if (facilities.length > 0) {
			// Pick some random facility and go!
			val destination = facilities.get(rand.nextInt(facilities.length - 1))
			performAction(playerName, new Action("goto", new Identifier(destination)))
			agent_says("I will start navigating towards {0}", destination)
		} else {
			agent_shouts("I just don't know any facility to go, sorry...!")
		}
	}


	/** 
	 * A basic method for sending actions the the EIS server
	 * If sending fails, the exception is caught and logged. 
	 */
	def performAction(playerName : String, action : Action) {
		agent_says("Performing action {1} for player {0}", playerName, action.toProlog())
		try {
			// perform the action by agentName in the EIS
			MT_executeAction(playerName, action)
		} catch (e : ActException) {
			if (action !== null)
				warning("Could not perform action {0} for player {1}", action, playerName)
		}
	}

}
// /////////////////////////////////////////////////
// END OF FILE
// ///////////////////////////////////////////////// 